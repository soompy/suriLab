exports.id=288,exports.ids=[288],exports.modules={31183:(t,e,r)=>{"use strict";r.d(e,{z:()=>i});var s=r(96330);let i=globalThis.prisma??new s.PrismaClient({log:["query"]})},46268:(t,e,r)=>{"use strict";r.d(e,{EX:()=>q,Rr:()=>N,iy:()=>j,N7:()=>v});var s=r(32190);class i{constructor(t){this.prisma=t}async findAll(t,e,r){let s={};if(t){if(t.category&&(s.category={name:t.category}),t.tags&&t.tags.length>0&&(s.tags={some:{name:{in:t.tags}}}),t.authorId&&(s.authorId=t.authorId),t.searchQuery){let e=t.searchQuery.toLowerCase();s.OR=[{title:{contains:e,mode:"insensitive"}},{excerpt:{contains:e,mode:"insensitive"}},{content:{contains:e,mode:"insensitive"}},{tags:{some:{name:{contains:e,mode:"insensitive"}}}}]}void 0!==t.featured&&(s.featured=t.featured),void 0!==t.isPublished&&(s.isPublished=t.isPublished)}let i={};e?i[e.field]=e.order:i.publishedAt="desc";let a=r?.page||1,o=r?.limit||10,[n,c]=await Promise.all([this.prisma.post.findMany({where:s,orderBy:i,skip:(a-1)*o,take:o,include:{tags:!0,category:!0,author:!0}}),this.prisma.post.count({where:s})]);return{posts:n.map(this.mapToEntity),total:c,page:a,totalPages:Math.ceil(c/o)}}async findById(t){let e=await this.prisma.post.findUnique({where:{id:t},include:{tags:!0,category:!0,author:!0}});return e?this.mapToEntity(e):null}async findBySlug(t){let e=await this.prisma.post.findUnique({where:{slug:t},include:{tags:!0,category:!0,author:!0}});return e?this.mapToEntity(e):null}async create(t){let e=await this.prisma.category.upsert({where:{name:t.category},update:{},create:{name:t.category}}),r=await this.prisma.user.upsert({where:{id:t.authorId},update:{},create:{id:t.authorId,name:"Blog Author",email:"author@example.com"}}),s=await this.prisma.post.create({data:{title:t.title,content:t.content,excerpt:t.excerpt,slug:t.slug,featured:t.featured||!1,isPublished:t.isPublished||!1,readTime:Math.ceil(t.content.split(" ").length/200),categoryId:e.id,authorId:r.id,tags:{connectOrCreate:t.tags.map(t=>({where:{name:t},create:{name:t}}))}},include:{tags:!0,category:!0,author:!0}});return this.mapToEntity(s)}async update(t){let e={};t.title&&(e.title=t.title),t.content&&(e.content=t.content,e.readTime=Math.ceil(t.content.split(" ").length/200)),t.excerpt&&(e.excerpt=t.excerpt),t.slug&&(e.slug=t.slug),void 0!==t.featured&&(e.featured=t.featured),void 0!==t.isPublished&&(e.isPublished=t.isPublished),t.category&&(e.categoryId=(await this.prisma.category.upsert({where:{name:t.category},update:{},create:{name:t.category}})).id),t.tags&&(e.tags={set:[],connectOrCreate:t.tags.map(t=>({where:{name:t},create:{name:t}}))});let r=await this.prisma.post.update({where:{id:t.id},data:e,include:{tags:!0,category:!0,author:!0}});return this.mapToEntity(r)}async delete(t){await this.prisma.post.delete({where:{id:t}})}async incrementViews(t){await this.prisma.post.update({where:{id:t},data:{views:{increment:1}}})}async getCategories(){return(await this.prisma.category.findMany({select:{name:!0}})).map(t=>t.name)}async getTags(){return(await this.prisma.tag.findMany({select:{name:!0}})).map(t=>t.name)}async getStats(){let[t,e,r,s]=await Promise.all([this.prisma.post.count(),this.prisma.post.aggregate({_sum:{views:!0}}),this.prisma.category.count(),this.prisma.tag.count()]);return{totalPosts:t,totalViews:e._sum.views||0,totalCategories:r,totalTags:s}}mapToEntity(t){return{id:t.id,title:t.title,content:t.content,excerpt:t.excerpt,slug:t.slug,publishedAt:t.publishedAt,updatedAt:t.updatedAt,tags:t.tags.map(t=>t.name),category:t.category.name,authorId:t.authorId,readTime:t.readTime,views:t.views,featured:t.featured,isPublished:t.isPublished}}}class a{constructor(t){this.postRepository=t}async execute(t,e,r){return await this.postRepository.findAll(t,e||{field:"publishedAt",order:"desc"},r||{page:1,limit:10})}}class o{constructor(t){this.postRepository=t}async execute(t){let e=await this.postRepository.findById(t);return e&&await this.postRepository.incrementViews(t),e}}class n{constructor(t){this.postRepository=t}async execute(t){let e=await this.postRepository.findBySlug(t);return e&&await this.postRepository.incrementViews(e.id),e}}class c{constructor(t){this.postRepository=t}async execute(){let[t,e,r]=await Promise.all([this.postRepository.getStats(),this.postRepository.getCategories(),this.postRepository.getTags()]);return{...t,categories:e,tags:r}}}class u{constructor(t){this.postRepository=t}async execute(t){if(this.validateInput(t),await this.postRepository.findBySlug(t.slug))throw Error("Post with this slug already exists");return await this.postRepository.create(t)}validateInput(t){if(!t.title.trim())throw Error("Title is required");if(!t.content.trim())throw Error("Content is required");if(!t.excerpt.trim())throw Error("Excerpt is required");if(!t.slug.trim())throw Error("Slug is required");if(!t.category.trim())throw Error("Category is required");if(!t.authorId.trim())throw Error("Author ID is required");if(0===t.tags.length)throw Error("At least one tag is required");if(!/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(t.slug))throw Error("Slug must be lowercase alphanumeric with hyphens only")}}class l{constructor(t){this.postRepository=t}async execute(t){this.validateInput(t);let e=await this.postRepository.findById(t.id);if(!e)throw Error("Post not found");if(t.slug&&t.slug!==e.slug){let e=await this.postRepository.findBySlug(t.slug);if(e&&e.id!==t.id)throw Error("Post with this slug already exists")}return await this.postRepository.update(t)}validateInput(t){if(!t.id.trim())throw Error("Post ID is required");if(void 0!==t.title&&!t.title.trim())throw Error("Title cannot be empty");if(void 0!==t.content&&!t.content.trim())throw Error("Content cannot be empty");if(void 0!==t.excerpt&&!t.excerpt.trim())throw Error("Excerpt cannot be empty");if(void 0!==t.category&&!t.category.trim())throw Error("Category cannot be empty");if(void 0!==t.tags&&0===t.tags.length)throw Error("At least one tag is required");if(void 0!==t.slug&&!/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(t.slug))throw Error("Slug must be lowercase alphanumeric with hyphens only")}}class d{constructor(t){this.postRepository=t}async execute(t){if(!t.trim())throw Error("Post ID is required");if(!await this.postRepository.findById(t))throw Error("Post not found");await this.postRepository.delete(t)}}let p=new i(r(31183).z),h=new a(p),g=new o(p),y=new n(p),w=new c(p),m=new u(p),f=new l(p),x=new d(p);async function E(t,e,r){try{return await h.execute(t,e,r)}catch(t){throw console.error("Error getting posts:",t),t}}async function R(t){try{return await g.execute(t)}catch(t){throw console.error("Error getting post by id:",t),t}}async function v(t){try{return await y.execute(t)}catch(t){throw console.error("Error getting post by slug:",t),t}}async function b(){try{return await w.execute()}catch(t){throw console.error("Error getting blog stats:",t),t}}async function P(t){try{return await m.execute(t)}catch(t){throw console.error("Error creating post:",t),t}}async function I(t){try{return await f.execute(t)}catch(t){throw console.error("Error updating post:",t),t}}async function T(t){try{return await x.execute(t)}catch(t){throw console.error("Error deleting post:",t),t}}class j{static async GET(t){try{let{searchParams:e}=new URL(t.url),r=e.get("category")||void 0,i=e.get("tags")?.split(",")||void 0,a=e.get("authorId")||void 0,o=e.get("search")||void 0,n="true"===e.get("featured")||void 0,c="false"!==e.get("isPublished")||"false"!==e.get("isPublished")&&void 0,u=e.get("sortField")||"publishedAt",l=e.get("sortOrder")||"desc",d=parseInt(e.get("page")||"1"),p=parseInt(e.get("limit")||"10"),h=await E({category:r,tags:i,authorId:a,searchQuery:o,featured:n,isPublished:c},{field:u,order:l},{page:d,limit:p});return s.NextResponse.json(h)}catch{return s.NextResponse.json({error:"Failed to fetch posts"},{status:500})}}static async POST(t){try{let e=await t.json(),r=await P(e);return s.NextResponse.json(r,{status:201})}catch{return s.NextResponse.json({error:"Failed to create post"},{status:400})}}}class N{static async GET(t,{params:e}){try{let t=await R(e.id);if(!t)return s.NextResponse.json({error:"Post not found"},{status:404});return s.NextResponse.json(t)}catch{return s.NextResponse.json({error:"Failed to fetch post"},{status:500})}}static async PUT(t,{params:e}){try{let r=await t.json(),i={id:e.id,...r},a=await I(i);return s.NextResponse.json(a)}catch{return s.NextResponse.json({error:"Failed to update post"},{status:400})}}static async DELETE(t,{params:e}){try{return await T(e.id),s.NextResponse.json({success:!0})}catch{return s.NextResponse.json({error:"Failed to delete post"},{status:400})}}}class q{static async GET(){try{let t=await b();return s.NextResponse.json(t)}catch{return s.NextResponse.json({error:"Failed to fetch blog stats"},{status:500})}}}},78335:()=>{},96487:()=>{}};